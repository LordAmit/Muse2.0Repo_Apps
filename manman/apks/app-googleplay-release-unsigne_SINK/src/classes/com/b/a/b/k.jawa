record `com.b.a.b.k` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
procedure `void` `<init>`(`com.b.a.b.k` v0 @kind this) @signature `Lcom/b/a/b/k;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;

  #L157ee0.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L157ee6.  return @kind void;
}
procedure `com.b.a.b.k` `a`() @signature `Lcom/b/a/b/k;.a:()Lcom/b/a/b/k;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #Try_start0.  
  #L157ef8.  v0:= "sun.misc.Unsafe" @kind object;
  #L157efc.  call temp:= `forName`(v0) @signature `Ljava/lang/Class;.forName:(Ljava/lang/String;)Ljava/lang/Class;` @kind static;
  #L157f02.  v0:= temp @kind object;
  #L157f04.  v1:= "theUnsafe" @kind object;
  #L157f08.  call temp:= `getDeclaredField`(v0, v1) @signature `Ljava/lang/Class;.getDeclaredField:(Ljava/lang/String;)Ljava/lang/reflect/Field;` @kind virtual;
  #L157f0e.  v1:= temp @kind object;
  #L157f10.  v2:= 1I;
  #L157f12.  call `setAccessible`(v1, v2) @signature `Ljava/lang/reflect/Field;.setAccessible:(Z)V` @kind virtual;
  #L157f18.  v2:= 0I;
  #L157f1a.  call temp:= `get`(v1, v2) @signature `Ljava/lang/reflect/Field;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L157f20.  v1:= temp @kind object;
  #L157f22.  v2:= "allocateInstance" @kind object;
  #L157f26.  v3:= 1I;
  #L157f28.  v3:= new `java.lang.Class`[v3];
  #L157f2c.  v4:= 0I;
  #L157f2e.  v5:= constclass @type ^`java.lang.Class` @kind object;
  #L157f32.  v3[v4]:= v5 @kind object;
  #L157f36.  call temp:= `getMethod`(v0, v2, v3) @signature `Ljava/lang/Class;.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L157f3c.  v2:= temp @kind object;
  #L157f3e.  v0:= new `com.b.a.b.k$1`;
  #L157f42.  call `<init>`(v0, v2, v1) @signature `Lcom/b/a/b/k$1;.<init>:(Ljava/lang/reflect/Method;Ljava/lang/Object;)V` @kind direct;
  #Try_end0.  
  #L157f48.  return v0 @kind object;
  #L157f4a.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #Try_start1.  
  #L157f4c.  v0:= constclass @type ^`java.io.ObjectStreamClass` @kind object;
  #L157f50.  v1:= "getConstructorId" @kind object;
  #L157f54.  v2:= 1I;
  #L157f56.  v2:= new `java.lang.Class`[v2];
  #L157f5a.  v3:= 0I;
  #L157f5c.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L157f60.  v2[v3]:= v4 @kind object;
  #L157f64.  call temp:= `getDeclaredMethod`(v0, v1, v2) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L157f6a.  v0:= temp @kind object;
  #L157f6c.  v1:= 1I;
  #L157f6e.  call `setAccessible`(v0, v1) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L157f74.  v1:= 0I;
  #L157f76.  v2:= 1I;
  #L157f78.  v2:= new `java.lang.Object`[v2];
  #L157f7c.  v3:= 0I;
  #L157f7e.  v4:= constclass @type ^`java.lang.Object` @kind object;
  #L157f82.  v2[v3]:= v4 @kind object;
  #L157f86.  call temp:= `invoke`(v0, v1, v2) @signature `Ljava/lang/reflect/Method;.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L157f8c.  v0:= temp @kind object;
  #L157f8e.  v0:= (`java.lang.Integer`) v0 @kind object;
  #L157f92.  call temp:= `intValue`(v0) @signature `Ljava/lang/Integer;.intValue:()I` @kind virtual;
  #L157f98.  v1:= temp;
  #L157f9a.  v0:= constclass @type ^`java.io.ObjectStreamClass` @kind object;
  #L157f9e.  v2:= "newInstance" @kind object;
  #L157fa2.  v3:= 2I;
  #L157fa4.  v3:= new `java.lang.Class`[v3];
  #L157fa8.  v4:= 0I;
  #L157faa.  v5:= constclass @type ^`java.lang.Class` @kind object;
  #L157fae.  v3[v4]:= v5 @kind object;
  #L157fb2.  v4:= 1I;
  #L157fb4.  v5:= `@@java.lang.Integer.TYPE` @type ^`java.lang.Class` @kind object;
  #L157fb8.  v3[v4]:= v5 @kind object;
  #L157fbc.  call temp:= `getDeclaredMethod`(v0, v2, v3) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L157fc2.  v2:= temp @kind object;
  #L157fc4.  v0:= 1I;
  #L157fc6.  call `setAccessible`(v2, v0) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L157fcc.  v0:= new `com.b.a.b.k$2`;
  #L157fd0.  call `<init>`(v0, v2, v1) @signature `Lcom/b/a/b/k$2;.<init>:(Ljava/lang/reflect/Method;I)V` @kind direct;
  #Try_end1.  
  #L157fd6.  goto L157f48;
  #L157fd8.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #Try_start2.  
  #L157fda.  v0:= constclass @type ^`java.io.ObjectInputStream` @kind object;
  #L157fde.  v1:= "newInstance" @kind object;
  #L157fe2.  v2:= 2I;
  #L157fe4.  v2:= new `java.lang.Class`[v2];
  #L157fe8.  v3:= 0I;
  #L157fea.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L157fee.  v2[v3]:= v4 @kind object;
  #L157ff2.  v3:= 1I;
  #L157ff4.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L157ff8.  v2[v3]:= v4 @kind object;
  #L157ffc.  call temp:= `getDeclaredMethod`(v0, v1, v2) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L158002.  v1:= temp @kind object;
  #L158004.  v0:= 1I;
  #L158006.  call `setAccessible`(v1, v0) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L15800c.  v0:= new `com.b.a.b.k$3`;
  #L158010.  call `<init>`(v0, v1) @signature `Lcom/b/a/b/k$3;.<init>:(Ljava/lang/reflect/Method;)V` @kind direct;
  #Try_end2.  
  #L158016.  goto L157f48;
  #L158018.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #L15801a.  v0:= new `com.b.a.b.k$4`;
  #L15801e.  call `<init>`(v0) @signature `Lcom/b/a/b/k$4;.<init>:()V` @kind direct;
  #L158024.  goto L157f48;
  catch `java.lang.Exception` @[Try_start0..Try_end0] goto L157f4a;
  catch `java.lang.Exception` @[Try_start1..Try_end1] goto L157fd8;
  catch `java.lang.Exception` @[Try_start2..Try_end2] goto L158018;
}
procedure `void` `b`(`java.lang.Class` v0 @kind object) @signature `Lcom/b/a/b/k;.b:(Ljava/lang/Class;)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L158060.  call `c`(v0) @signature `Lcom/b/a/b/k;.c:(Ljava/lang/Class;)V` @kind static;
  #L158066.  return @kind void;
}
procedure `void` `c`(`java.lang.Class` v3 @kind object) @signature `Lcom/b/a/b/k;.c:(Ljava/lang/Class;)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L158078.  call temp:= `getModifiers`(v3) @signature `Ljava/lang/Class;.getModifiers:()I` @kind virtual;
  #L15807e.  v0:= temp;
  #L158080.  call temp:= `isInterface`(v0) @signature `Ljava/lang/reflect/Modifier;.isInterface:(I)Z` @kind static;
  #L158086.  v1:= temp;
  #L158088.  if v1 == 0 then goto L1580c6;
  #L15808c.  v0:= new `java.lang.UnsupportedOperationException`;
  #L158090.  v1:= new `java.lang.StringBuilder`;
  #L158094.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L15809a.  v2:= "Interface can't be instantiated! Interface name: " @kind object;
  #L15809e.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1580a4.  v1:= temp @kind object;
  #L1580a6.  call temp:= `getName`(v3) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L1580ac.  v2:= temp @kind object;
  #L1580ae.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1580b4.  v1:= temp @kind object;
  #L1580b6.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1580bc.  v1:= temp @kind object;
  #L1580be.  call `<init>`(v0, v1) @signature `Ljava/lang/UnsupportedOperationException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1580c4.  throw v0;
  #L1580c6.  call temp:= `isAbstract`(v0) @signature `Ljava/lang/reflect/Modifier;.isAbstract:(I)Z` @kind static;
  #L1580cc.  v0:= temp;
  #L1580ce.  if v0 == 0 then goto L15810c;
  #L1580d2.  v0:= new `java.lang.UnsupportedOperationException`;
  #L1580d6.  v1:= new `java.lang.StringBuilder`;
  #L1580da.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1580e0.  v2:= "Abstract class can't be instantiated! Class name: " @kind object;
  #L1580e4.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1580ea.  v1:= temp @kind object;
  #L1580ec.  call temp:= `getName`(v3) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L1580f2.  v2:= temp @kind object;
  #L1580f4.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1580fa.  v1:= temp @kind object;
  #L1580fc.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L158102.  v1:= temp @kind object;
  #L158104.  call `<init>`(v0, v1) @signature `Ljava/lang/UnsupportedOperationException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L15810a.  throw v0;
  #L15810c.  return @kind void;
}
procedure `java.lang.Object` `a`(`java.lang.Class` v0 @kind object) @signature `Lcom/b/a/b/k;.a:(Ljava/lang/Class;)Ljava/lang/Object;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
