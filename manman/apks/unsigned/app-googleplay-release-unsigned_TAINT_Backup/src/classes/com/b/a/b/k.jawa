record `com.b.a.b.k` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
procedure `void` `<init>`(`com.b.a.b.k` v0 @kind this) @signature `Lcom/b/a/b/k;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;

  #L13cda8.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L13cdae.  return @kind void;
}
procedure `com.b.a.b.k` `a`() @signature `Lcom/b/a/b/k;.a:()Lcom/b/a/b/k;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #Try_start0.  
  #L13cdc0.  v0:= "sun.misc.Unsafe" @kind object;
  #L13cdc4.  call temp:= `forName`(v0) @signature `Ljava/lang/Class;.forName:(Ljava/lang/String;)Ljava/lang/Class;` @kind static;
  #L13cdca.  v0:= temp @kind object;
  #L13cdcc.  v1:= "theUnsafe" @kind object;
  #L13cdd0.  call temp:= `getDeclaredField`(v0, v1) @signature `Ljava/lang/Class;.getDeclaredField:(Ljava/lang/String;)Ljava/lang/reflect/Field;` @kind virtual;
  #L13cdd6.  v1:= temp @kind object;
  #L13cdd8.  v2:= 1I;
  #L13cdda.  call `setAccessible`(v1, v2) @signature `Ljava/lang/reflect/Field;.setAccessible:(Z)V` @kind virtual;
  #L13cde0.  v2:= 0I;
  #L13cde2.  call temp:= `get`(v1, v2) @signature `Ljava/lang/reflect/Field;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L13cde8.  v1:= temp @kind object;
  #L13cdea.  v2:= "allocateInstance" @kind object;
  #L13cdee.  v3:= 1I;
  #L13cdf0.  v3:= new `java.lang.Class`[v3];
  #L13cdf4.  v4:= 0I;
  #L13cdf6.  v5:= constclass @type ^`java.lang.Class` @kind object;
  #L13cdfa.  v3[v4]:= v5 @kind object;
  #L13cdfe.  call temp:= `getMethod`(v0, v2, v3) @signature `Ljava/lang/Class;.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L13ce04.  v2:= temp @kind object;
  #L13ce06.  v0:= new `com.b.a.b.k$1`;
  #L13ce0a.  call `<init>`(v0, v2, v1) @signature `Lcom/b/a/b/k$1;.<init>:(Ljava/lang/reflect/Method;Ljava/lang/Object;)V` @kind direct;
  #Try_end0.  
  #L13ce10.  return v0 @kind object;
  #L13ce12.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #Try_start1.  
  #L13ce14.  v0:= constclass @type ^`java.io.ObjectStreamClass` @kind object;
  #L13ce18.  v1:= "getConstructorId" @kind object;
  #L13ce1c.  v2:= 1I;
  #L13ce1e.  v2:= new `java.lang.Class`[v2];
  #L13ce22.  v3:= 0I;
  #L13ce24.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L13ce28.  v2[v3]:= v4 @kind object;
  #L13ce2c.  call temp:= `getDeclaredMethod`(v0, v1, v2) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L13ce32.  v0:= temp @kind object;
  #L13ce34.  v1:= 1I;
  #L13ce36.  call `setAccessible`(v0, v1) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L13ce3c.  v1:= 0I;
  #L13ce3e.  v2:= 1I;
  #L13ce40.  v2:= new `java.lang.Object`[v2];
  #L13ce44.  v3:= 0I;
  #L13ce46.  v4:= constclass @type ^`java.lang.Object` @kind object;
  #L13ce4a.  v2[v3]:= v4 @kind object;
  #L13ce4e.  call temp:= `invoke`(v0, v1, v2) @signature `Ljava/lang/reflect/Method;.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L13ce54.  v0:= temp @kind object;
  #L13ce56.  v0:= (`java.lang.Integer`) v0 @kind object;
  #L13ce5a.  call temp:= `intValue`(v0) @signature `Ljava/lang/Integer;.intValue:()I` @kind virtual;
  #L13ce60.  v1:= temp;
  #L13ce62.  v0:= constclass @type ^`java.io.ObjectStreamClass` @kind object;
  #L13ce66.  v2:= "newInstance" @kind object;
  #L13ce6a.  v3:= 2I;
  #L13ce6c.  v3:= new `java.lang.Class`[v3];
  #L13ce70.  v4:= 0I;
  #L13ce72.  v5:= constclass @type ^`java.lang.Class` @kind object;
  #L13ce76.  v3[v4]:= v5 @kind object;
  #L13ce7a.  v4:= 1I;
  #L13ce7c.  v5:= `@@java.lang.Integer.TYPE` @type ^`java.lang.Class` @kind object;
  #L13ce80.  v3[v4]:= v5 @kind object;
  #L13ce84.  call temp:= `getDeclaredMethod`(v0, v2, v3) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L13ce8a.  v2:= temp @kind object;
  #L13ce8c.  v0:= 1I;
  #L13ce8e.  call `setAccessible`(v2, v0) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L13ce94.  v0:= new `com.b.a.b.k$2`;
  #L13ce98.  call `<init>`(v0, v2, v1) @signature `Lcom/b/a/b/k$2;.<init>:(Ljava/lang/reflect/Method;I)V` @kind direct;
  #Try_end1.  
  #L13ce9e.  goto L13ce10;
  #L13cea0.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #Try_start2.  
  #L13cea2.  v0:= constclass @type ^`java.io.ObjectInputStream` @kind object;
  #L13cea6.  v1:= "newInstance" @kind object;
  #L13ceaa.  v2:= 2I;
  #L13ceac.  v2:= new `java.lang.Class`[v2];
  #L13ceb0.  v3:= 0I;
  #L13ceb2.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L13ceb6.  v2[v3]:= v4 @kind object;
  #L13ceba.  v3:= 1I;
  #L13cebc.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L13cec0.  v2[v3]:= v4 @kind object;
  #L13cec4.  call temp:= `getDeclaredMethod`(v0, v1, v2) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L13ceca.  v1:= temp @kind object;
  #L13cecc.  v0:= 1I;
  #L13cece.  call `setAccessible`(v1, v0) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L13ced4.  v0:= new `com.b.a.b.k$3`;
  #L13ced8.  call `<init>`(v0, v1) @signature `Lcom/b/a/b/k$3;.<init>:(Ljava/lang/reflect/Method;)V` @kind direct;
  #Try_end2.  
  #L13cede.  goto L13ce10;
  #L13cee0.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #L13cee2.  v0:= new `com.b.a.b.k$4`;
  #L13cee6.  call `<init>`(v0) @signature `Lcom/b/a/b/k$4;.<init>:()V` @kind direct;
  #L13ceec.  goto L13ce10;
  catch `java.lang.Exception` @[Try_start0..Try_end0] goto L13ce12;
  catch `java.lang.Exception` @[Try_start1..Try_end1] goto L13cea0;
  catch `java.lang.Exception` @[Try_start2..Try_end2] goto L13cee0;
}
procedure `void` `b`(`java.lang.Class` v0 @kind object) @signature `Lcom/b/a/b/k;.b:(Ljava/lang/Class;)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L13cf28.  call `c`(v0) @signature `Lcom/b/a/b/k;.c:(Ljava/lang/Class;)V` @kind static;
  #L13cf2e.  return @kind void;
}
procedure `void` `c`(`java.lang.Class` v3 @kind object) @signature `Lcom/b/a/b/k;.c:(Ljava/lang/Class;)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L13cf40.  call temp:= `getModifiers`(v3) @signature `Ljava/lang/Class;.getModifiers:()I` @kind virtual;
  #L13cf46.  v0:= temp;
  #L13cf48.  call temp:= `isInterface`(v0) @signature `Ljava/lang/reflect/Modifier;.isInterface:(I)Z` @kind static;
  #L13cf4e.  v1:= temp;
  #L13cf50.  if v1 == 0 then goto L13cf8e;
  #L13cf54.  v0:= new `java.lang.UnsupportedOperationException`;
  #L13cf58.  v1:= new `java.lang.StringBuilder`;
  #L13cf5c.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L13cf62.  v2:= "Interface can't be instantiated! Interface name: " @kind object;
  #L13cf66.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L13cf6c.  v1:= temp @kind object;
  #L13cf6e.  call temp:= `getName`(v3) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L13cf74.  v2:= temp @kind object;
  #L13cf76.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L13cf7c.  v1:= temp @kind object;
  #L13cf7e.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L13cf84.  v1:= temp @kind object;
  #L13cf86.  call `<init>`(v0, v1) @signature `Ljava/lang/UnsupportedOperationException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L13cf8c.  throw v0;
  #L13cf8e.  call temp:= `isAbstract`(v0) @signature `Ljava/lang/reflect/Modifier;.isAbstract:(I)Z` @kind static;
  #L13cf94.  v0:= temp;
  #L13cf96.  if v0 == 0 then goto L13cfd4;
  #L13cf9a.  v0:= new `java.lang.UnsupportedOperationException`;
  #L13cf9e.  v1:= new `java.lang.StringBuilder`;
  #L13cfa2.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L13cfa8.  v2:= "Abstract class can't be instantiated! Class name: " @kind object;
  #L13cfac.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L13cfb2.  v1:= temp @kind object;
  #L13cfb4.  call temp:= `getName`(v3) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L13cfba.  v2:= temp @kind object;
  #L13cfbc.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L13cfc2.  v1:= temp @kind object;
  #L13cfc4.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L13cfca.  v1:= temp @kind object;
  #L13cfcc.  call `<init>`(v0, v1) @signature `Ljava/lang/UnsupportedOperationException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L13cfd2.  throw v0;
  #L13cfd4.  return @kind void;
}
procedure `java.lang.Object` `a`(`java.lang.Class` v0 @kind object) @signature `Lcom/b/a/b/k;.a:(Ljava/lang/Class;)Ljava/lang/Object;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
