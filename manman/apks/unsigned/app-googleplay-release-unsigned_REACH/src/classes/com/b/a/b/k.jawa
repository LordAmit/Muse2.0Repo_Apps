record `com.b.a.b.k` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
procedure `void` `<init>`(`com.b.a.b.k` v0 @kind this) @signature `Lcom/b/a/b/k;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;

  #L146af0.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L146af6.  return @kind void;
}
procedure `com.b.a.b.k` `a`() @signature `Lcom/b/a/b/k;.a:()Lcom/b/a/b/k;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #Try_start0.  
  #L146b08.  v0:= "sun.misc.Unsafe" @kind object;
  #L146b0c.  call temp:= `forName`(v0) @signature `Ljava/lang/Class;.forName:(Ljava/lang/String;)Ljava/lang/Class;` @kind static;
  #L146b12.  v0:= temp @kind object;
  #L146b14.  v1:= "theUnsafe" @kind object;
  #L146b18.  call temp:= `getDeclaredField`(v0, v1) @signature `Ljava/lang/Class;.getDeclaredField:(Ljava/lang/String;)Ljava/lang/reflect/Field;` @kind virtual;
  #L146b1e.  v1:= temp @kind object;
  #L146b20.  v2:= 1I;
  #L146b22.  call `setAccessible`(v1, v2) @signature `Ljava/lang/reflect/Field;.setAccessible:(Z)V` @kind virtual;
  #L146b28.  v2:= 0I;
  #L146b2a.  call temp:= `get`(v1, v2) @signature `Ljava/lang/reflect/Field;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L146b30.  v1:= temp @kind object;
  #L146b32.  v2:= "allocateInstance" @kind object;
  #L146b36.  v3:= 1I;
  #L146b38.  v3:= new `java.lang.Class`[v3];
  #L146b3c.  v4:= 0I;
  #L146b3e.  v5:= constclass @type ^`java.lang.Class` @kind object;
  #L146b42.  v3[v4]:= v5 @kind object;
  #L146b46.  call temp:= `getMethod`(v0, v2, v3) @signature `Ljava/lang/Class;.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L146b4c.  v2:= temp @kind object;
  #L146b4e.  v0:= new `com.b.a.b.k$1`;
  #L146b52.  call `<init>`(v0, v2, v1) @signature `Lcom/b/a/b/k$1;.<init>:(Ljava/lang/reflect/Method;Ljava/lang/Object;)V` @kind direct;
  #Try_end0.  
  #L146b58.  return v0 @kind object;
  #L146b5a.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #Try_start1.  
  #L146b5c.  v0:= constclass @type ^`java.io.ObjectStreamClass` @kind object;
  #L146b60.  v1:= "getConstructorId" @kind object;
  #L146b64.  v2:= 1I;
  #L146b66.  v2:= new `java.lang.Class`[v2];
  #L146b6a.  v3:= 0I;
  #L146b6c.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L146b70.  v2[v3]:= v4 @kind object;
  #L146b74.  call temp:= `getDeclaredMethod`(v0, v1, v2) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L146b7a.  v0:= temp @kind object;
  #L146b7c.  v1:= 1I;
  #L146b7e.  call `setAccessible`(v0, v1) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L146b84.  v1:= 0I;
  #L146b86.  v2:= 1I;
  #L146b88.  v2:= new `java.lang.Object`[v2];
  #L146b8c.  v3:= 0I;
  #L146b8e.  v4:= constclass @type ^`java.lang.Object` @kind object;
  #L146b92.  v2[v3]:= v4 @kind object;
  #L146b96.  call temp:= `invoke`(v0, v1, v2) @signature `Ljava/lang/reflect/Method;.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L146b9c.  v0:= temp @kind object;
  #L146b9e.  v0:= (`java.lang.Integer`) v0 @kind object;
  #L146ba2.  call temp:= `intValue`(v0) @signature `Ljava/lang/Integer;.intValue:()I` @kind virtual;
  #L146ba8.  v1:= temp;
  #L146baa.  v0:= constclass @type ^`java.io.ObjectStreamClass` @kind object;
  #L146bae.  v2:= "newInstance" @kind object;
  #L146bb2.  v3:= 2I;
  #L146bb4.  v3:= new `java.lang.Class`[v3];
  #L146bb8.  v4:= 0I;
  #L146bba.  v5:= constclass @type ^`java.lang.Class` @kind object;
  #L146bbe.  v3[v4]:= v5 @kind object;
  #L146bc2.  v4:= 1I;
  #L146bc4.  v5:= `@@java.lang.Integer.TYPE` @type ^`java.lang.Class` @kind object;
  #L146bc8.  v3[v4]:= v5 @kind object;
  #L146bcc.  call temp:= `getDeclaredMethod`(v0, v2, v3) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L146bd2.  v2:= temp @kind object;
  #L146bd4.  v0:= 1I;
  #L146bd6.  call `setAccessible`(v2, v0) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L146bdc.  v0:= new `com.b.a.b.k$2`;
  #L146be0.  call `<init>`(v0, v2, v1) @signature `Lcom/b/a/b/k$2;.<init>:(Ljava/lang/reflect/Method;I)V` @kind direct;
  #Try_end1.  
  #L146be6.  goto L146b58;
  #L146be8.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #Try_start2.  
  #L146bea.  v0:= constclass @type ^`java.io.ObjectInputStream` @kind object;
  #L146bee.  v1:= "newInstance" @kind object;
  #L146bf2.  v2:= 2I;
  #L146bf4.  v2:= new `java.lang.Class`[v2];
  #L146bf8.  v3:= 0I;
  #L146bfa.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L146bfe.  v2[v3]:= v4 @kind object;
  #L146c02.  v3:= 1I;
  #L146c04.  v4:= constclass @type ^`java.lang.Class` @kind object;
  #L146c08.  v2[v3]:= v4 @kind object;
  #L146c0c.  call temp:= `getDeclaredMethod`(v0, v1, v2) @signature `Ljava/lang/Class;.getDeclaredMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;` @kind virtual;
  #L146c12.  v1:= temp @kind object;
  #L146c14.  v0:= 1I;
  #L146c16.  call `setAccessible`(v1, v0) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L146c1c.  v0:= new `com.b.a.b.k$3`;
  #L146c20.  call `<init>`(v0, v1) @signature `Lcom/b/a/b/k$3;.<init>:(Ljava/lang/reflect/Method;)V` @kind direct;
  #Try_end2.  
  #L146c26.  goto L146b58;
  #L146c28.  v0:= Exception @type ^`java.lang.Exception` @kind object;
  #L146c2a.  v0:= new `com.b.a.b.k$4`;
  #L146c2e.  call `<init>`(v0) @signature `Lcom/b/a/b/k$4;.<init>:()V` @kind direct;
  #L146c34.  goto L146b58;
  catch `java.lang.Exception` @[Try_start0..Try_end0] goto L146b5a;
  catch `java.lang.Exception` @[Try_start1..Try_end1] goto L146be8;
  catch `java.lang.Exception` @[Try_start2..Try_end2] goto L146c28;
}
procedure `void` `b`(`java.lang.Class` v0 @kind object) @signature `Lcom/b/a/b/k;.b:(Ljava/lang/Class;)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L146c70.  call `c`(v0) @signature `Lcom/b/a/b/k;.c:(Ljava/lang/Class;)V` @kind static;
  #L146c76.  return @kind void;
}
procedure `void` `c`(`java.lang.Class` v3 @kind object) @signature `Lcom/b/a/b/k;.c:(Ljava/lang/Class;)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L146c88.  call temp:= `getModifiers`(v3) @signature `Ljava/lang/Class;.getModifiers:()I` @kind virtual;
  #L146c8e.  v0:= temp;
  #L146c90.  call temp:= `isInterface`(v0) @signature `Ljava/lang/reflect/Modifier;.isInterface:(I)Z` @kind static;
  #L146c96.  v1:= temp;
  #L146c98.  if v1 == 0 then goto L146cd6;
  #L146c9c.  v0:= new `java.lang.UnsupportedOperationException`;
  #L146ca0.  v1:= new `java.lang.StringBuilder`;
  #L146ca4.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L146caa.  v2:= "Interface can't be instantiated! Interface name: " @kind object;
  #L146cae.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L146cb4.  v1:= temp @kind object;
  #L146cb6.  call temp:= `getName`(v3) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L146cbc.  v2:= temp @kind object;
  #L146cbe.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L146cc4.  v1:= temp @kind object;
  #L146cc6.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L146ccc.  v1:= temp @kind object;
  #L146cce.  call `<init>`(v0, v1) @signature `Ljava/lang/UnsupportedOperationException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L146cd4.  throw v0;
  #L146cd6.  call temp:= `isAbstract`(v0) @signature `Ljava/lang/reflect/Modifier;.isAbstract:(I)Z` @kind static;
  #L146cdc.  v0:= temp;
  #L146cde.  if v0 == 0 then goto L146d1c;
  #L146ce2.  v0:= new `java.lang.UnsupportedOperationException`;
  #L146ce6.  v1:= new `java.lang.StringBuilder`;
  #L146cea.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L146cf0.  v2:= "Abstract class can't be instantiated! Class name: " @kind object;
  #L146cf4.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L146cfa.  v1:= temp @kind object;
  #L146cfc.  call temp:= `getName`(v3) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L146d02.  v2:= temp @kind object;
  #L146d04.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L146d0a.  v1:= temp @kind object;
  #L146d0c.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L146d12.  v1:= temp @kind object;
  #L146d14.  call `<init>`(v0, v1) @signature `Ljava/lang/UnsupportedOperationException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L146d1a.  throw v0;
  #L146d1c.  return @kind void;
}
procedure `java.lang.Object` `a`(`java.lang.Class` v0 @kind object) @signature `Lcom/b/a/b/k;.a:(Ljava/lang/Class;)Ljava/lang/Object;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
