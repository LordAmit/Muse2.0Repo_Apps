record `okio.Buffer$UnsafeCursor` @kind class @AccessFlag PUBLIC_FINAL extends `java.io.Closeable` @kind interface {
  `okio.Buffer` `okio.Buffer$UnsafeCursor.buffer` @AccessFlag PUBLIC;
  `byte`[] `okio.Buffer$UnsafeCursor.data` @AccessFlag PUBLIC;
  `int` `okio.Buffer$UnsafeCursor.end` @AccessFlag PUBLIC;
  `long` `okio.Buffer$UnsafeCursor.offset` @AccessFlag PUBLIC;
  `boolean` `okio.Buffer$UnsafeCursor.readWrite` @AccessFlag PUBLIC;
  `okio.Segment` `okio.Buffer$UnsafeCursor.segment` @AccessFlag PRIVATE;
  `int` `okio.Buffer$UnsafeCursor.start` @AccessFlag PUBLIC;
}
procedure `void` `<init>`(`okio.Buffer$UnsafeCursor` v3 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;
    v2;

  #L1ac234.  v2:= -1I;
  #L1ac236.  call `<init>`(v3) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L1ac23c.  v0:= -1L;
  #L1ac240.  v3.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L1ac244.  v3.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v2;
  #L1ac248.  v3.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v2;
  #L1ac24c.  return @kind void;
}
procedure `void` `close`(`okio.Buffer$UnsafeCursor` v4 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.close:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L1ac260.  v3:= -1I;
  #L1ac262.  v2:= 0I;
  #L1ac264.  v0:= v4.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac268.  if v0 != 0 then goto L1ac27c;
  #L1ac26c.  v0:= new `java.lang.IllegalStateException`;
  #L1ac270.  v1:= "not attached to a buffer" @kind object;
  #L1ac274.  call `<init>`(v0, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac27a.  throw v0;
  #L1ac27c.  v4.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` := v2 @kind object;
  #L1ac280.  v4.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v2 @kind object;
  #L1ac284.  v0:= -1L;
  #L1ac288.  v4.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L1ac28c.  v4.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v2 @kind object;
  #L1ac290.  v4.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v3;
  #L1ac294.  v4.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v3;
  #L1ac298.  return @kind void;
}
procedure `long` `expandBuffer`(`okio.Buffer$UnsafeCursor` v8 @kind this, `int` v9 @name `minByteCount`) @signature `Lokio/Buffer$UnsafeCursor;.expandBuffer:(I)J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L1ac2ac.  v5:= 8192I;
  #L1ac2b0.  if v9 > 0 then goto L1ac2e6;
  #L1ac2b4.  v4:= new `java.lang.IllegalArgumentException`;
  #L1ac2b8.  v5:= new `java.lang.StringBuilder`;
  #L1ac2bc.  call `<init>`(v5) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1ac2c2.  v6:= "minByteCount <= 0: " @kind object;
  #L1ac2c6.  call temp:= `append`(v5, v6) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ac2cc.  v5:= temp @kind object;
  #L1ac2ce.  call temp:= `append`(v5, v9) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ac2d4.  v5:= temp @kind object;
  #L1ac2d6.  call temp:= `toString`(v5) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1ac2dc.  v5:= temp @kind object;
  #L1ac2de.  call `<init>`(v4, v5) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac2e4.  throw v4;
  #L1ac2e6.  if v9 <= v5 then goto L1ac31c;
  #L1ac2ea.  v4:= new `java.lang.IllegalArgumentException`;
  #L1ac2ee.  v5:= new `java.lang.StringBuilder`;
  #L1ac2f2.  call `<init>`(v5) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1ac2f8.  v6:= "minByteCount > Segment.SIZE: " @kind object;
  #L1ac2fc.  call temp:= `append`(v5, v6) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ac302.  v5:= temp @kind object;
  #L1ac304.  call temp:= `append`(v5, v9) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ac30a.  v5:= temp @kind object;
  #L1ac30c.  call temp:= `toString`(v5) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1ac312.  v5:= temp @kind object;
  #L1ac314.  call `<init>`(v4, v5) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac31a.  throw v4;
  #L1ac31c.  v4:= v8.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac320.  if v4 != 0 then goto L1ac334;
  #L1ac324.  v4:= new `java.lang.IllegalStateException`;
  #L1ac328.  v5:= "not attached to a buffer" @kind object;
  #L1ac32c.  call `<init>`(v4, v5) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac332.  throw v4;
  #L1ac334.  v4:= v8.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L1ac338.  if v4 != 0 then goto L1ac34c;
  #L1ac33c.  v4:= new `java.lang.IllegalStateException`;
  #L1ac340.  v5:= "expandBuffer() only permitted for read/write buffers" @kind object;
  #L1ac344.  call `<init>`(v4, v5) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac34a.  throw v4;
  #L1ac34c.  v4:= v8.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac350.  v0:= v4.`okio.Buffer.size` @type ^`long` @kind wide;
  #L1ac354.  v4:= v8.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac358.  call temp:= `writableSegment`(v4, v9) @signature `Lokio/Buffer;.writableSegment:(I)Lokio/Segment;` @kind virtual;
  #L1ac35e.  v3:= temp @kind object;
  #L1ac360.  v4:= v3.`okio.Segment.limit` @type ^`int`;
  #L1ac364.  v2:= v4 - 8192;
  #L1ac368.  v3.`okio.Segment.limit` @type ^`int` := v5;
  #L1ac36c.  v4:= v8.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac370.  v6:= (`long`) v2 @kind i2l;
  #L1ac372.  v6:= v6 + v0 @kind long;
  #L1ac374.  v4.`okio.Buffer.size` @type ^`long` := v6 @kind wide;
  #L1ac378.  v8.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v3 @kind object;
  #L1ac37c.  v8.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L1ac380.  v4:= v3.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L1ac384.  v8.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v4 @kind object;
  #L1ac388.  v4:= v2 - 8192;
  #L1ac38c.  v8.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v4;
  #L1ac390.  v8.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v5;
  #L1ac394.  v4:= (`long`) v2 @kind i2l;
  #L1ac396.  return v4 @kind wide;
}
procedure `int` `next`(`okio.Buffer$UnsafeCursor` v4 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.next:()I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L1ac3a8.  v0:= v4.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L1ac3ac.  v2:= v4.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac3b0.  v2:= v2.`okio.Buffer.size` @type ^`long` @kind wide;
  #L1ac3b4.  v0:= lcmp(v0, v2);
  #L1ac3b8.  if v0 != 0 then goto L1ac3c8;
  #L1ac3bc.  v0:= new `java.lang.IllegalStateException`;
  #L1ac3c0.  call `<init>`(v0) @signature `Ljava/lang/IllegalStateException;.<init>:()V` @kind direct;
  #L1ac3c6.  throw v0;
  #L1ac3c8.  v0:= v4.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L1ac3cc.  v2:= -1L;
  #L1ac3d0.  v0:= lcmp(v0, v2);
  #L1ac3d4.  if v0 != 0 then goto L1ac3e6;
  #L1ac3d8.  v0:= 0L;
  #L1ac3dc.  call temp:= `seek`(v4, v0) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @kind virtual;
  #L1ac3e2.  v0:= temp;
  #L1ac3e4.  return v0;
  #L1ac3e6.  v0:= v4.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L1ac3ea.  v2:= v4.`okio.Buffer$UnsafeCursor.end` @type ^`int`;
  #L1ac3ee.  v3:= v4.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L1ac3f2.  v2:= v2 - v3 @kind int;
  #L1ac3f4.  v2:= (`long`) v2 @kind i2l;
  #L1ac3f6.  v0:= v0 + v2 @kind long;
  #L1ac3f8.  call temp:= `seek`(v4, v0) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @kind virtual;
  #L1ac3fe.  v0:= temp;
  #L1ac400.  goto L1ac3e4;
}
procedure `long` `resizeBuffer`(`okio.Buffer$UnsafeCursor` v13 @kind this, `long` v14 @name `newSize`) @signature `Lokio/Buffer$UnsafeCursor;.resizeBuffer:(J)J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;

  #L1ac414.  v10:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac418.  if v10 != 0 then goto L1ac42c;
  #L1ac41c.  v10:= new `java.lang.IllegalStateException`;
  #L1ac420.  v11:= "not attached to a buffer" @kind object;
  #L1ac424.  call `<init>`(v10, v11) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac42a.  throw v10;
  #L1ac42c.  v10:= v13.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L1ac430.  if v10 != 0 then goto L1ac444;
  #L1ac434.  v10:= new `java.lang.IllegalStateException`;
  #L1ac438.  v11:= "resizeBuffer() only permitted for read/write buffers" @kind object;
  #L1ac43c.  call `<init>`(v10, v11) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac442.  throw v10;
  #L1ac444.  v10:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac448.  v6:= v10.`okio.Buffer.size` @type ^`long` @kind wide;
  #L1ac44c.  v10:= lcmp(v14, v6);
  #L1ac450.  if v10 > 0 then goto L1ac514;
  #L1ac454.  v10:= 0L;
  #L1ac458.  v10:= lcmp(v14, v10);
  #L1ac45c.  if v10 >= 0 then goto L1ac492;
  #L1ac460.  v10:= new `java.lang.IllegalArgumentException`;
  #L1ac464.  v11:= new `java.lang.StringBuilder`;
  #L1ac468.  call `<init>`(v11) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1ac46e.  v12:= "newSize < 0: " @kind object;
  #L1ac472.  call temp:= `append`(v11, v12) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ac478.  v11:= temp @kind object;
  #L1ac47a.  call temp:= `append`(v11, v14) @signature `Ljava/lang/StringBuilder;.append:(J)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ac480.  v11:= temp @kind object;
  #L1ac482.  call temp:= `toString`(v11) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1ac488.  v11:= temp @kind object;
  #L1ac48a.  call `<init>`(v10, v11) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac490.  throw v10;
  #L1ac492.  v2:= v6 - v14 @kind long;
  #L1ac496.  v10:= 0L;
  #L1ac49a.  v10:= lcmp(v2, v10);
  #L1ac49e.  if v10 <= 0 then goto L1ac4ee;
  #L1ac4a2.  v10:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac4a6.  v10:= v10.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L1ac4aa.  v8:= v10.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L1ac4ae.  v10:= v8.`okio.Segment.limit` @type ^`int`;
  #L1ac4b2.  v11:= v8.`okio.Segment.pos` @type ^`int`;
  #L1ac4b6.  v9:= v10 - v11 @kind int;
  #L1ac4ba.  v10:= (`long`) v9 @kind i2l;
  #L1ac4bc.  v10:= lcmp(v10, v2);
  #L1ac4c0.  if v10 > 0 then goto L1ac4e0;
  #L1ac4c4.  v10:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac4c8.  call temp:= `pop`(v8) @signature `Lokio/Segment;.pop:()Lokio/Segment;` @kind virtual;
  #L1ac4ce.  v11:= temp @kind object;
  #L1ac4d0.  v10.`okio.Buffer.head` @type ^`okio.Segment` := v11 @kind object;
  #L1ac4d4.  call `recycle`(v8) @signature `Lokio/SegmentPool;.recycle:(Lokio/Segment;)V` @kind static;
  #L1ac4da.  v10:= (`long`) v9 @kind i2l;
  #L1ac4dc.  v2:= v2 - v10 @kind long;
  #L1ac4de.  goto L1ac496;
  #L1ac4e0.  v10:= v8.`okio.Segment.limit` @type ^`int`;
  #L1ac4e4.  v10:= (`long`) v10 @kind i2l;
  #L1ac4e6.  v10:= v10 - v2 @kind long;
  #L1ac4e8.  v10:= (`int`) v10 @kind l2i;
  #L1ac4ea.  v8.`okio.Segment.limit` @type ^`int` := v10;
  #L1ac4ee.  v10:= 0I;
  #L1ac4f0.  v13.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v10 @kind object;
  #L1ac4f4.  v13.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v14 @kind wide;
  #L1ac4f8.  v10:= 0I;
  #L1ac4fa.  v13.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v10 @kind object;
  #L1ac4fe.  v10:= -1I;
  #L1ac500.  v13.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v10;
  #L1ac504.  v10:= -1I;
  #L1ac506.  v13.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v10;
  #L1ac50a.  v10:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac50e.  v10.`okio.Buffer.size` @type ^`long` := v14 @kind wide;
  #L1ac512.  return v6 @kind wide;
  #L1ac514.  v10:= lcmp(v14, v6);
  #L1ac518.  if v10 <= 0 then goto L1ac50a;
  #L1ac51c.  v4:= 1I;
  #L1ac51e.  v0:= v14 - v6 @kind long;
  #L1ac522.  v10:= 0L;
  #L1ac526.  v10:= lcmp(v0, v10);
  #L1ac52a.  if v10 <= 0 then goto L1ac50a;
  #L1ac52e.  v10:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac532.  v11:= 1I;
  #L1ac534.  call temp:= `writableSegment`(v10, v11) @signature `Lokio/Buffer;.writableSegment:(I)Lokio/Segment;` @kind virtual;
  #L1ac53a.  v8:= temp @kind object;
  #L1ac53c.  v10:= v8.`okio.Segment.limit` @type ^`int`;
  #L1ac540.  v10:= v10 - 8192;
  #L1ac544.  v10:= (`long`) v10 @kind i2l;
  #L1ac546.  call temp:= `min`(v0, v10) @signature `Ljava/lang/Math;.min:(JJ)J` @kind static;
  #L1ac54c.  v10:= temp @kind wide;
  #L1ac54e.  v5:= (`int`) v10 @kind l2i;
  #L1ac550.  v10:= v8.`okio.Segment.limit` @type ^`int`;
  #L1ac554.  v10:= v10 + v5 @kind int;
  #L1ac556.  v8.`okio.Segment.limit` @type ^`int` := v10;
  #L1ac55a.  v10:= (`long`) v5 @kind i2l;
  #L1ac55c.  v0:= v0 - v10 @kind long;
  #L1ac55e.  if v4 == 0 then goto L1ac522;
  #L1ac562.  v13.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v8 @kind object;
  #L1ac566.  v13.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v6 @kind wide;
  #L1ac56a.  v10:= v8.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L1ac56e.  v13.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v10 @kind object;
  #L1ac572.  v10:= v8.`okio.Segment.limit` @type ^`int`;
  #L1ac576.  v10:= v10 - v5 @kind int;
  #L1ac578.  v13.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v10;
  #L1ac57c.  v10:= v8.`okio.Segment.limit` @type ^`int`;
  #L1ac580.  v13.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v10;
  #L1ac584.  v4:= 0I;
  #L1ac586.  goto L1ac522;
}
procedure `int` `seek`(`okio.Buffer$UnsafeCursor` v23 @kind this, `long` v24 @name `offset`) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;
    v17;
    v18;
    v19;
    v20;
    v21;
    v22;

  #L1ac598.  v16:= -1L;
  #L1ac59c.  v16:= lcmp(v24, v16);
  #L1ac5a0.  if v16 < 0 then goto L1ac5c4;
  #L1ac5a4.  v0:= v23 @kind object;
  #L1ac5a8.  v0:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac5ac.  v16:= v0 @kind object;
  #L1ac5b0.  v0:= v16 @kind object;
  #L1ac5b4.  v0:= v0.`okio.Buffer.size` @type ^`long` @kind wide;
  #L1ac5b8.  v16:= v0 @kind wide;
  #L1ac5bc.  v16:= lcmp(v24, v16);
  #L1ac5c0.  if v16 <= 0 then goto L1ac624;
  #L1ac5c4.  v16:= new `java.lang.ArrayIndexOutOfBoundsException`;
  #L1ac5c8.  v17:= "offset=%s > size=%s" @kind object;
  #L1ac5cc.  v18:= 2I;
  #L1ac5d0.  v0:= v18;
  #L1ac5d4.  v0:= new `java.lang.Object`[v0];
  #L1ac5d8.  v18:= v0 @kind object;
  #L1ac5dc.  v19:= 0I;
  #L1ac5e0.  call temp:= `valueOf`(v24) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L1ac5e6.  v20:= temp @kind object;
  #L1ac5e8.  v18[v19]:= v20 @kind object;
  #L1ac5ec.  v19:= 1I;
  #L1ac5f0.  v0:= v23 @kind object;
  #L1ac5f4.  v0:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac5f8.  v20:= v0 @kind object;
  #L1ac5fc.  v0:= v20 @kind object;
  #L1ac600.  v0:= v0.`okio.Buffer.size` @type ^`long` @kind wide;
  #L1ac604.  v20:= v0 @kind wide;
  #L1ac608.  call temp:= `valueOf`(v20) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L1ac60e.  v20:= temp @kind object;
  #L1ac610.  v18[v19]:= v20 @kind object;
  #L1ac614.  call temp:= `format`(v17, v18) @signature `Ljava/lang/String;.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;` @kind static;
  #L1ac61a.  v17:= temp @kind object;
  #L1ac61c.  call `<init>`(v16, v17) @signature `Ljava/lang/ArrayIndexOutOfBoundsException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1ac622.  throw v16;
  #L1ac624.  v16:= -1L;
  #L1ac628.  v16:= lcmp(v24, v16);
  #L1ac62c.  if v16 == 0 then goto L1ac650;
  #L1ac630.  v0:= v23 @kind object;
  #L1ac634.  v0:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac638.  v16:= v0 @kind object;
  #L1ac63c.  v0:= v16 @kind object;
  #L1ac640.  v0:= v0.`okio.Buffer.size` @type ^`long` @kind wide;
  #L1ac644.  v16:= v0 @kind wide;
  #L1ac648.  v16:= lcmp(v24, v16);
  #L1ac64c.  if v16 != 0 then goto L1ac6a2;
  #L1ac650.  v16:= 0I;
  #L1ac654.  v0:= v16 @kind object;
  #L1ac658.  v1:= v23 @kind object;
  #L1ac65c.  v1.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v0 @kind object;
  #L1ac660.  v0:= v24 @kind wide;
  #L1ac664.  v2:= v23 @kind object;
  #L1ac668.  v2.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L1ac66c.  v16:= 0I;
  #L1ac670.  v0:= v16 @kind object;
  #L1ac674.  v1:= v23 @kind object;
  #L1ac678.  v1.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L1ac67c.  v16:= -1I;
  #L1ac680.  v0:= v16;
  #L1ac684.  v1:= v23 @kind object;
  #L1ac688.  v1.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L1ac68c.  v16:= -1I;
  #L1ac690.  v0:= v16;
  #L1ac694.  v1:= v23 @kind object;
  #L1ac698.  v1.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L1ac69c.  v16:= -1I;
  #L1ac6a0.  return v16;
  #L1ac6a2.  v8:= 0L;
  #L1ac6a6.  v0:= v23 @kind object;
  #L1ac6aa.  v0:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac6ae.  v16:= v0 @kind object;
  #L1ac6b2.  v0:= v16 @kind object;
  #L1ac6b6.  v6:= v0.`okio.Buffer.size` @type ^`long` @kind wide;
  #L1ac6ba.  v0:= v23 @kind object;
  #L1ac6be.  v0:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac6c2.  v16:= v0 @kind object;
  #L1ac6c6.  v0:= v16 @kind object;
  #L1ac6ca.  v4:= v0.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L1ac6ce.  v0:= v23 @kind object;
  #L1ac6d2.  v0:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac6d6.  v16:= v0 @kind object;
  #L1ac6da.  v0:= v16 @kind object;
  #L1ac6de.  v14:= v0.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L1ac6e2.  v0:= v23 @kind object;
  #L1ac6e6.  v0:= v0.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` @kind object;
  #L1ac6ea.  v16:= v0 @kind object;
  #L1ac6ee.  if v16 == 0 then goto L1ac746;
  #L1ac6f2.  v0:= v23 @kind object;
  #L1ac6f6.  v0:= v0.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L1ac6fa.  v16:= v0 @kind wide;
  #L1ac6fe.  v0:= v23 @kind object;
  #L1ac702.  v0:= v0.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L1ac706.  v18:= v0;
  #L1ac70a.  v0:= v23 @kind object;
  #L1ac70e.  v0:= v0.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` @kind object;
  #L1ac712.  v19:= v0 @kind object;
  #L1ac716.  v0:= v19 @kind object;
  #L1ac71a.  v0:= v0.`okio.Segment.pos` @type ^`int`;
  #L1ac71e.  v19:= v0;
  #L1ac722.  v18:= v18 - v19 @kind int;
  #L1ac726.  v0:= v18;
  #L1ac72a.  v0:= (`long`) v0 @kind i2l;
  #L1ac72c.  v18:= v0 @kind wide;
  #L1ac730.  v12:= v16 - v18 @kind long;
  #L1ac734.  v16:= lcmp(v12, v24);
  #L1ac738.  if v16 <= 0 then goto L1ac7ac;
  #L1ac73c.  v6:= v12 @kind wide;
  #L1ac73e.  v0:= v23 @kind object;
  #L1ac742.  v14:= v0.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` @kind object;
  #L1ac746.  v16:= v6 - v24 @kind long;
  #L1ac74a.  v18:= v24 - v8 @kind long;
  #L1ac74e.  v16:= lcmp(v16, v18);
  #L1ac752.  if v16 <= 0 then goto L1ac7b8;
  #L1ac756.  v5:= v4 @kind object;
  #L1ac758.  v10:= v8 @kind wide;
  #L1ac75a.  v0:= v5.`okio.Segment.limit` @type ^`int`;
  #L1ac75e.  v16:= v0;
  #L1ac762.  v0:= v5.`okio.Segment.pos` @type ^`int`;
  #L1ac766.  v17:= v0;
  #L1ac76a.  v16:= v16 - v17 @kind int;
  #L1ac76e.  v0:= v16;
  #L1ac772.  v0:= (`long`) v0 @kind i2l;
  #L1ac774.  v16:= v0 @kind wide;
  #L1ac778.  v16:= v16 + v10 @kind long;
  #L1ac77c.  v16:= lcmp(v24, v16);
  #L1ac780.  if v16 < 0 then goto L1ac7ec;
  #L1ac784.  v0:= v5.`okio.Segment.limit` @type ^`int`;
  #L1ac788.  v16:= v0;
  #L1ac78c.  v0:= v5.`okio.Segment.pos` @type ^`int`;
  #L1ac790.  v17:= v0;
  #L1ac794.  v16:= v16 - v17 @kind int;
  #L1ac798.  v0:= v16;
  #L1ac79c.  v0:= (`long`) v0 @kind i2l;
  #L1ac79e.  v16:= v0 @kind wide;
  #L1ac7a2.  v10:= v10 + v16 @kind long;
  #L1ac7a6.  v5:= v5.`okio.Segment.next` @type ^`okio.Segment` @kind object;
  #L1ac7aa.  goto L1ac75a;
  #L1ac7ac.  v8:= v12 @kind wide;
  #L1ac7ae.  v0:= v23 @kind object;
  #L1ac7b2.  v4:= v0.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` @kind object;
  #L1ac7b6.  goto L1ac746;
  #L1ac7b8.  v5:= v14 @kind object;
  #L1ac7ba.  v10:= v6 @kind wide;
  #L1ac7bc.  v16:= lcmp(v10, v24);
  #L1ac7c0.  if v16 <= 0 then goto L1ac7ec;
  #L1ac7c4.  v5:= v5.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L1ac7c8.  v0:= v5.`okio.Segment.limit` @type ^`int`;
  #L1ac7cc.  v16:= v0;
  #L1ac7d0.  v0:= v5.`okio.Segment.pos` @type ^`int`;
  #L1ac7d4.  v17:= v0;
  #L1ac7d8.  v16:= v16 - v17 @kind int;
  #L1ac7dc.  v0:= v16;
  #L1ac7e0.  v0:= (`long`) v0 @kind i2l;
  #L1ac7e2.  v16:= v0 @kind wide;
  #L1ac7e6.  v10:= v10 - v16 @kind long;
  #L1ac7ea.  goto L1ac7bc;
  #L1ac7ec.  v0:= v23 @kind object;
  #L1ac7f0.  v0:= v0.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L1ac7f4.  v16:= v0;
  #L1ac7f8.  if v16 == 0 then goto L1ac85a;
  #L1ac7fc.  v0:= v5.`okio.Segment.shared` @type ^`boolean` @kind boolean;
  #L1ac800.  v16:= v0;
  #L1ac804.  if v16 == 0 then goto L1ac85a;
  #L1ac808.  call temp:= `unsharedCopy`(v5) @signature `Lokio/Segment;.unsharedCopy:()Lokio/Segment;` @kind virtual;
  #L1ac80e.  v15:= temp @kind object;
  #L1ac810.  v0:= v23 @kind object;
  #L1ac814.  v0:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac818.  v16:= v0 @kind object;
  #L1ac81c.  v0:= v16 @kind object;
  #L1ac820.  v0:= v0.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L1ac824.  v16:= v0 @kind object;
  #L1ac828.  v0:= v16 @kind object;
  #L1ac82c.  if v0 != v5 then goto L1ac844;
  #L1ac830.  v0:= v23 @kind object;
  #L1ac834.  v0:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1ac838.  v16:= v0 @kind object;
  #L1ac83c.  v0:= v16 @kind object;
  #L1ac840.  v0.`okio.Buffer.head` @type ^`okio.Segment` := v15 @kind object;
  #L1ac844.  call temp:= `push`(v5, v15) @signature `Lokio/Segment;.push:(Lokio/Segment;)Lokio/Segment;` @kind virtual;
  #L1ac84a.  v5:= temp @kind object;
  #L1ac84c.  v0:= v5.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L1ac850.  v16:= v0 @kind object;
  #L1ac854.  call temp:= `pop`(v16) @signature `Lokio/Segment;.pop:()Lokio/Segment;` @kind virtual;
  #L1ac85a.  v0:= v23 @kind object;
  #L1ac85e.  v0.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v5 @kind object;
  #L1ac862.  v0:= v24 @kind wide;
  #L1ac866.  v2:= v23 @kind object;
  #L1ac86a.  v2.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L1ac86e.  v0:= v5.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L1ac872.  v16:= v0 @kind object;
  #L1ac876.  v0:= v16 @kind object;
  #L1ac87a.  v1:= v23 @kind object;
  #L1ac87e.  v1.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L1ac882.  v0:= v5.`okio.Segment.pos` @type ^`int`;
  #L1ac886.  v16:= v0;
  #L1ac88a.  v18:= v24 - v10 @kind long;
  #L1ac88e.  v0:= v18 @kind wide;
  #L1ac892.  v0:= (`int`) v0 @kind l2i;
  #L1ac894.  v17:= v0;
  #L1ac898.  v16:= v16 + v17 @kind int;
  #L1ac89c.  v0:= v16;
  #L1ac8a0.  v1:= v23 @kind object;
  #L1ac8a4.  v1.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L1ac8a8.  v0:= v5.`okio.Segment.limit` @type ^`int`;
  #L1ac8ac.  v16:= v0;
  #L1ac8b0.  v0:= v16;
  #L1ac8b4.  v1:= v23 @kind object;
  #L1ac8b8.  v1.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L1ac8bc.  v0:= v23 @kind object;
  #L1ac8c0.  v0:= v0.`okio.Buffer$UnsafeCursor.end` @type ^`int`;
  #L1ac8c4.  v16:= v0;
  #L1ac8c8.  v0:= v23 @kind object;
  #L1ac8cc.  v0:= v0.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L1ac8d0.  v17:= v0;
  #L1ac8d4.  v16:= v16 - v17 @kind int;
  #L1ac8d8.  goto L1ac6a0;
}
